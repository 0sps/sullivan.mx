<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sean's  stylish text generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .options-container {
            width: 90%;
            max-width: 1200px;
            margin: 10px auto;
        }
        h3 {
            margin: 10px 0;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 90%;
            max-width: 1200px;
            margin: 20px auto;
        }
        .text-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .text-area label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        textarea {
            width: 100%;
            height: 300px;
            font-size: 16px;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: vertical;
        }
        #output {
            white-space: pre-wrap;
            background-color: #fff;
        }
        .copy-button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            align-self: flex-end;
        }
        .copy-button:hover {
            background-color: #45a049;
        }
        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .option-button {
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .option-button:hover {
            background-color: #e0e0e0;
        }
        .option-button.active {
            background-color: #007bff;
            color: white;
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            textarea {
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <h1>Stylish Text Generator</h1>
    <div class="container">
        <div class="text-area">
            <label for="input">Input Text:</label>
            <textarea id="input" placeholder="Type your text here..."></textarea>
        </div>
        <div class="text-area">
            <label for="output">Transformed Text:</label>
            <textarea id="output" readonly></textarea>
            <button class="copy-button" id="copyButton">Copy to Clipboard</button>
        </div>
    </div>
    
    <div class="options-container">
        <h3>Quick Copy Any Style (Click a button to copy that style):</h3>
        <div class="options" id="styleOptions">
            <!-- Style options will be added here by JavaScript -->
        </div>
    </div>

    <script>
        // Character maps for various styles
        const charMaps = {
            normal: {},
            bold: {},
            italic: {},
            boldItalic: {},
            script: {},
            boldScript: {},
            fraktur: {},
            boldFraktur: {},
            doubleStruck: {},
            sansSerif: {},
            sansSerifBold: {},
            sansSerifItalic: {},
            sansSerifBoldItalic: {},
            monospace: {},
            fullWidth: {},
            smallCaps: {},
            circled: {},
            negative: {},
            squared: {},
            boxed: {}
        };

        // Initialize normal lowercase letters map
        const lowerAlpha = 'abcdefghijklmnopqrstuvwxyz';
        const upperAlpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';

        // Math bold (ùêö-ùê≥, ùêÄ-ùêô, ùüé-ùüó)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.bold[lowerAlpha[i]] = String.fromCodePoint(0x1D41A + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.bold[upperAlpha[i]] = String.fromCodePoint(0x1D400 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.bold[numbers[i]] = String.fromCodePoint(0x1D7CE + i);
        }

        // Math italic (ùëé-ùëß, ùê¥-ùëç)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.italic[lowerAlpha[i]] = String.fromCodePoint(0x1D44E + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.italic[upperAlpha[i]] = String.fromCodePoint(0x1D434 + i);
        }

        // Math bold italic (ùíÇ-ùíõ, ùë®-ùíÅ)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.boldItalic[lowerAlpha[i]] = String.fromCodePoint(0x1D482 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boldItalic[upperAlpha[i]] = String.fromCodePoint(0x1D468 + i);
        }

        // Math script (ùì™-ùîÉ, ùìê-ùì©)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.script[lowerAlpha[i]] = String.fromCodePoint(0x1D4EA + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.script[upperAlpha[i]] = String.fromCodePoint(0x1D4D0 + i);
        }

        // Math bold script (ùì´-ùîÉ, ùìê-ùì©)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.boldScript[lowerAlpha[i]] = String.fromCodePoint(0x1D51E + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boldScript[upperAlpha[i]] = String.fromCodePoint(0x1D504 + i);
        }

        // Math fraktur (ùîû-ùî∑, ùîÑ-‚Ñ®)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.fraktur[lowerAlpha[i]] = String.fromCodePoint(0x1D586 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.fraktur[upperAlpha[i]] = String.fromCodePoint(0x1D56C + i);
        }

        // Math double-struck (ùïí-ùï´, ùî∏-‚Ñ§, ùüò-ùü°)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.doubleStruck[lowerAlpha[i]] = String.fromCodePoint(0x1D552 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.doubleStruck[upperAlpha[i]] = String.fromCodePoint(0x1D538 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.doubleStruck[numbers[i]] = String.fromCodePoint(0x1D7D8 + i);
        }

        // Sans-serif (ùñ∫-ùóì, ùñ†-ùñπ, ùü¢-ùü´)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerif[lowerAlpha[i]] = String.fromCodePoint(0x1D5BA + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerif[upperAlpha[i]] = String.fromCodePoint(0x1D5A0 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.sansSerif[numbers[i]] = String.fromCodePoint(0x1D7E2 + i);
        }

        // Sans-serif bold (ùóÆ-ùòá, ùóî-ùó≠, ùü¨-ùüµ)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerifBold[lowerAlpha[i]] = String.fromCodePoint(0x1D5EE + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerifBold[upperAlpha[i]] = String.fromCodePoint(0x1D5D4 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.sansSerifBold[numbers[i]] = String.fromCodePoint(0x1D7EC + i);
        }

        // Sans-serif italic (ùò¢-ùòª, ùòà-ùò°)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerifItalic[lowerAlpha[i]] = String.fromCodePoint(0x1D622 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerifItalic[upperAlpha[i]] = String.fromCodePoint(0x1D608 + i);
        }

        // Sans-serif bold italic (ùôñ-ùôØ, ùòº-ùôï)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerifBoldItalic[lowerAlpha[i]] = String.fromCodePoint(0x1D656 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerifBoldItalic[upperAlpha[i]] = String.fromCodePoint(0x1D63C + i);
        }

        // Monospace (ùöä-ùö£, ùô∞-ùöâ, ùü∂-ùüø)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.monospace[lowerAlpha[i]] = String.fromCodePoint(0x1D68A + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.monospace[upperAlpha[i]] = String.fromCodePoint(0x1D670 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.monospace[numbers[i]] = String.fromCodePoint(0x1D7F6 + i);
        }

        // Fullwidth (ÔΩÅ-ÔΩö, Ôº°-Ôº∫, Ôºê-Ôºô)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.fullWidth[lowerAlpha[i]] = String.fromCodePoint(0xFF41 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.fullWidth[upperAlpha[i]] = String.fromCodePoint(0xFF21 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.fullWidth[numbers[i]] = String.fromCodePoint(0xFF10 + i);
        }

        // Small caps - approximation for lowercase only
        const smallCapsChars = "·¥Ä ô·¥Ñ·¥Ö·¥áÍú∞…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ Äs·¥õ·¥ú·¥†·¥°x è·¥¢";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.smallCaps[lowerAlpha[i]] = smallCapsChars[i] || lowerAlpha[i];
        }

        // Circled (‚ìê-‚ì©, ‚í∂-‚ìè, ‚ì™-‚ë®)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.circled[lowerAlpha[i]] = String.fromCodePoint(0x24D0 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.circled[upperAlpha[i]] = String.fromCodePoint(0x24B6 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.circled[numbers[i]] = String.fromCodePoint(0x2460 + i - 1);
        }
        charMaps.circled['0'] = '‚ì™';

        // Negative circled (üÖê-üÖ©)
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.negative[upperAlpha[i]] = String.fromCodePoint(0x1F150 + i);
        }

        // Squared (üÑ∞-üÑπ)
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.squared[upperAlpha[i]] = String.fromCodePoint(0x1F130 + i);
        }

        // Boxed (üÖ∞-üÖâ)
        const boxedChars = "üÖ∞üÖ±üÖ≤üÖ≥üÖ¥üÖµüÖ∂üÖ∑üÖ∏üÖπüÖ∫üÖªüÖºüÖΩüÖæüÖøüÜÄüÜÅüÜÇüÜÉüÜÑüÜÖüÜÜüÜáüÜàüÜâ";
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boxed[upperAlpha[i]] = boxedChars[i] || upperAlpha[i];
        }

        // Special effects functions
        const effects = {
            normal: text => text,
            bold: text => applyCharMap(charMaps.bold, text),
            italic: text => applyCharMap(charMaps.italic, text),
            boldItalic: text => applyCharMap(charMaps.boldItalic, text),
            script: text => applyCharMap(charMaps.script, text),
            boldScript: text => applyCharMap(charMaps.boldScript, text),
            fraktur: text => applyCharMap(charMaps.fraktur, text),
            doubleStruck: text => applyCharMap(charMaps.doubleStruck, text),
            sansSerif: text => applyCharMap(charMaps.sansSerif, text),
            sansSerifBold: text => applyCharMap(charMaps.sansSerifBold, text),
            sansSerifItalic: text => applyCharMap(charMaps.sansSerifItalic, text),
            sansSerifBoldItalic: text => applyCharMap(charMaps.sansSerifBoldItalic, text),
            monospace: text => applyCharMap(charMaps.monospace, text),
            fullWidth: text => applyCharMap(charMaps.fullWidth, text),
            smallCaps: text => applyCharMap(charMaps.smallCaps, text),
            circled: text => applyCharMap(charMaps.circled, text),
            negative: text => applyCharMap(charMaps.negative, text),
            squared: text => applyCharMap(charMaps.squared, text),
            boxed: text => applyCharMap(charMaps.boxed, text),
            reversed: text => text.split('').reverse().join(''),
            strikeThrough: text => text.split('').join('Ã∂') + 'Ã∂',
            underline: text => text.split('').join('Ã≤') + 'Ã≤',
            zalgo: text => {
                const zalgo_up = ["\u030d","\u030e","\u0304","\u0305","\u033f","\u0311","\u0306"];
                const zalgo_mid = ["\u0315","\u031b","\u0340","\u0341","\u0358","\u0321"];
                const zalgo_down = ["\u0316","\u0317","\u0318","\u0319","\u031c","\u031d","\u031e","\u031f","\u0320","\u0324","\u0325","\u0326"];
                return text.split('').map(char => {
                    let result = char;
                    // Limit the number of combining characters to avoid extreme height
                    let numUp = Math.floor(Math.random() * 2) + 1;
                    let numMid = Math.floor(Math.random() * 2);
                    let numDown = Math.floor(Math.random() * 2) + 1;
                    
                    for (let i = 0; i < numUp; i++) {
                        result += zalgo_up[Math.floor(Math.random() * zalgo_up.length)];
                    }
                    for (let i = 0; i < numMid; i++) {
                        result += zalgo_mid[Math.floor(Math.random() * zalgo_mid.length)];
                    }
                    for (let i = 0; i < numDown; i++) {
                        result += zalgo_down[Math.floor(Math.random() * zalgo_down.length)];
                    }
                    return result;
                }).join('');
            },
            bubbleText: text => text.split('').map(c => {
                if (c.match(/[a-z]/i)) {
                    return charMaps.circled[c] || c;
                }
                return c;
            }).join(''),
            waveText: text => text.split('').map((c, i) => {
                const wave = ["‚ÇÅ", "‚ÇÇ", "‚ÇÉ", "‚ÇÑ", "‚ÇÉ", "‚ÇÇ"];
                return c + (wave[i % wave.length] || "");
            }).join(''),
            flourish: text => "‚òÖ‚ãÜÔΩ°¬∞‚ú© " + text + " ‚ú©¬∞ÔΩ°‚ãÜ‚òÖ",
            squiggle: text => "ÔΩûÔΩûÔΩû " + text + " ÔΩûÔΩûÔΩû",
            emojiDecor: text => "‚ú®üíñ " + text + " üíñ‚ú®",
            cursive: text => applyCharMap(charMaps.script, text),
            sparks: text => "‚ú®" + text.split('').join('‚ú®') + "‚ú®"
        };

        // Labels for the UI
        const effectLabels = {
            normal: "Normal",
            bold: "ùêÅùê®ùê•ùêù",
            italic: "ùêºùë°ùëéùëôùëñùëê",
            boldItalic: "ùë©ùíêùíçùíÖ ùë∞ùíïùíÇùíçùíäùíÑ",
            script: "ùì¢ùì¨ùìªùì≤ùìπùìΩ",
            boldScript: "ùìëùì∏ùìµùì≠ ùì¢ùì¨ùìªùì≤ùìπùìΩ",
            fraktur: "ùîâùîØùîûùî®ùî±ùî≤ùîØ",
            doubleStruck: "ùîªùï†ùï¶ùïìùïùùïñ ùïäùï•ùï£ùï¶ùïîùïú",
            sansSerif: "ùñ≤ùñ∫ùóáùóå ùñ≤ùñæùóãùóÇùñø",
            sansSerifBold: "ùó¶ùóÆùóªùòÄ ùó¶ùó≤ùóøùó∂ùó≥ ùóïùóºùóπùó±",
            sansSerifItalic: "ùòöùò¢ùòØùò¥ ùòöùò¶ùò≥ùò™ùòß ùòêùòµùò¢ùò≠ùò™ùò§",
            sansSerifBoldItalic: "ùôéùôñùô£ùô® ùôéùôöùôßùôûùôõ ùòΩùô§ùô°ùôô ùôÑùô©ùôñùô°ùôûùôò",
            monospace: "ùôºùöòùöóùöòùöúùöôùöäùöåùöé",
            fullWidth: "Ôº¶ÔΩïÔΩåÔΩå„ÄÄÔº∑ÔΩâÔΩÑÔΩîÔΩà",
            smallCaps: "s·¥ç·¥Ä ü ü ·¥Ñ·¥Ä·¥òs",
            circled: "‚í∏‚ìò‚ì°‚ìí‚ìõ‚ìî‚ìì",
            negative: "üÖùüÖîüÖñüÖêüÖ£üÖòüÖ•üÖî",
            squared: "üÑΩüÑ¥üÑ∂üÑ∞üÖÉüÑ∏üÖÖüÑ¥",
            boxed: "üÖ±üÖæüÜáüÖ¥üÖ≥",
            reversed: "desreveR",
            strikeThrough: "SÃ∂tÃ∂rÃ∂iÃ∂kÃ∂eÃ∂tÃ∂hÃ∂rÃ∂oÃ∂uÃ∂gÃ∂hÃ∂",
            underline: "UÃ≤nÃ≤dÃ≤eÃ≤rÃ≤lÃ≤iÃ≤nÃ≤eÃ≤",
            zalgo: "ZÃ∏Ã¢ÃóÃ•Ã™Ã£ÕöÃ≠ÕñÃ≠ÃúÕçÃ†Ã©ÃôÃÆÃ∫ÕéÃ†Ã™Ã£ÃºÃØÃÄÃìÕÇÃîÕãÃàÃÅÃÄÃÉÃàÃÄÃêÃïÃöÕùaÃ¥ÃóÃÆÃ†ÃÆÃùÃùÃúÕôÃ§Ã•ÃπÃºÃÆÃ†ÃóÕâÃ©ÃúÃ≠ÃπÃπÃ£ÃπÃçÃçÃìÃÉÃÉÃãÃèÃàÃÅÃàÃìÃîÃêÃöÕùlÃ∏Ã°ÃßÃ™ÃûÃüÃÆÃ≠ÃªÃ©Ã¨Ã¨Ã•Ã•ÃπÃûÃòÃ¨ÃóÃ†ÃúÕíÃäÃÅÃìÃÅÃÉÕêÃÖÕùÕùÕÖ«ßÃ¥Ã¢Ã®Ã±ÃùÃñÃ¨Ã≥Ã´Ã¨ÕñÃªÕéÕçÃ™ÃîÃøÃìÃëÃÜÃáÃçÃìÃøÕíÃæÃæÃèÃÑÃåÃÅÃíÕ†·ªèÃ∏Ã°ÃπÃÆÕìÃÆÃÆÃ†ÃûÃ©ÃñÃôÃùÃ£Ã¶ÃóÃªÃìÃÇÃèÕíÕåÕêÃÖÕõÃëÃÑÃéÃàÃäÃöÕùÕù",
            bubbleText: "‚í∑‚ì§‚ìë‚ìë‚ìõ‚ìî",
            waveText: "W‚ÇÅa‚ÇÇv‚ÇÉe‚ÇÑ",
            flourish: "‚òÖ‚ãÜÔΩ°¬∞‚ú© Flourish ‚ú©¬∞ÔΩ°‚ãÜ‚òÖ",
            squiggle: "ÔΩûÔΩûÔΩû Squiggle ÔΩûÔΩûÔΩû",
            emojiDecor: "‚ú®üíñ Emoji üíñ‚ú®",
            cursive: "ùíûùìäùìáùìàùíæùìãùëí",
            sparks: "‚ú®S‚ú®p‚ú®a‚ú®r‚ú®k‚ú®s‚ú®"
        };

        // Function to apply character map to text
        function applyCharMap(map, text) {
            return text.split('').map(c => map[c] || c).join('');
        }

        // Create style option buttons
        const styleOptionsDiv = document.getElementById('styleOptions');
        let currentStyle = 'normal';

        for (const style in effects) {
            const button = document.createElement('button');
            button.className = 'option-button';
            button.textContent = effectLabels[style] || style;
            button.dataset.style = style;
            
            button.addEventListener('click', function() {
                const text = inputArea.value;
                if (text) {
                    // Apply just this effect and copy it to clipboard
                    const transformed = effects[this.dataset.style](text);
                    outputArea.value = transformed;
                    outputArea.select();
                    document.execCommand('copy');
                    
                    // Visual feedback
                    this.classList.add('active');
                    setTimeout(() => {
                        this.classList.remove('active');
                        // Restore all transformations after copying
                        updateOutput();
                    }, 1000);
                    
                    copyButton.textContent = 'Copied!';
                    setTimeout(() => {
                        copyButton.textContent = 'Copy to Clipboard';
                    }, 2000);
                }
            });
            
            styleOptionsDiv.appendChild(button);
        }

        // Set up event listeners
        const inputArea = document.getElementById('input');
        const outputArea = document.getElementById('output');
        const copyButton = document.getElementById('copyButton');

        inputArea.addEventListener('input', updateOutput);

        copyButton.addEventListener('click', function() {
            outputArea.select();
            document.execCommand('copy');
            
            // Visual feedback
            this.textContent = 'Copied!';
            setTimeout(() => {
                this.textContent = 'Copy to Clipboard';
            }, 2000);
        });

        // Function to update output with all transformations
        function updateOutput() {
            const text = inputArea.value;
            if (text) {
                let output = "";
                // Apply all effects
                for (const effect in effects) {
                    if (effects.hasOwnProperty(effect)) {
                        const transformed = effects[effect](text);
                        output += transformed + "\n\n";
                    }
                }
                outputArea.value = output.trim();
            } else {
                outputArea.value = '';
            }
        }
    </script>
</body>
</html>