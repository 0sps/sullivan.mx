<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sean's stylish text generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .options-container {
            width: 90%;
            max-width: 1200px;
            margin: 10px auto;
        }
        h3 {
            margin: 10px 0;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 90%;
            max-width: 1200px;
            margin: 20px auto;
        }
        .text-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .text-area label {
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        textarea {
            width: 100%;
            height: 300px;
            font-size: 16px;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            resize: vertical;
        }
        #output {
            white-space: pre-wrap;
            background-color: #fff;
            overflow-y: auto;
        }
        .copy-button {
            margin-top: 10px;
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            align-self: flex-end;
        }
        .copy-button:hover {
            background-color: #45a049;
        }
        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .option-button {
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .option-button:hover {
            background-color: #e0e0e0;
        }
        .option-button.active {
            background-color: #007bff;
            color: white;
        }
        /* New styles for special symbols section */
        .special-symbols-container {
            width: 90%;
            max-width: 1200px;
            margin: 30px auto 10px;
            padding: 15px;
            background-color: #e8f4ff;
            border-radius: 6px;
            border: 1px solid #b8daff;
        }
        .symbol-button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 18px;
            min-width: 150px;
        }
        .symbol-button:hover {
            background-color: #0069d9;
        }
        .style-label {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
            display: block;
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            textarea {
                height: 200px;
            }
        }
    </style>
</head>
<body>
<!-- Google Looker Studio Embed -->
<div style="width:100%; max-width:1200px; margin:20px auto;">
  <iframe 
      width="100%" 
      height="100%" 
      src="https://lookerstudio.google.com/embed/reporting/73e61f50-7336-418d-9d10-60530b1371af/page/x8qXF" 
      frameborder="0" 
      style="border:0" 
      allowfullscreen>
  </iframe>
</div>
    <h1>Stylish Text Generator</h1>
    <div class="container">
        <div class="text-area">
            <label for="input">Input Text:</label>
            <textarea id="input" placeholder="Type your text here..."></textarea>
        </div>
        <div class="text-area">
            <label for="output">All Transformed Styles:</label>
            <textarea id="output" readonly></textarea>
            <button class="copy-button" id="copyButton">Copy to Clipboard</button>
        </div>
    </div>
    
    <div class="options-container">
        <h3>Quick Copy Any Style (Click a button to copy that style):</h3>
        <div class="options" id="styleOptions">
            <!-- Style options will be added here by JavaScript -->
            <button class="option-button" data-style="normal">Normal</button>
            <button class="option-button" data-style="bold">ğğ¨ğ¥ğ</button>
            <button class="option-button" data-style="italic">ğ¼ğ‘¡ğ‘ğ‘™ğ‘–ğ‘</button>
            <button class="option-button" data-style="boldItalic">ğ‘©ğ’ğ’ğ’… ğ‘°ğ’•ğ’‚ğ’ğ’Šğ’„</button>
            <button class="option-button" data-style="script">ğ“¢ğ“¬ğ“»ğ“²ğ“¹ğ“½</button>
            <button class="option-button" data-style="boldScript">ğ“‘ğ“¸ğ“µğ“­ ğ“¢ğ“¬ğ“»ğ“²ğ“¹ğ“½</button>
            <button class="option-button" data-style="fraktur">ğ”‰ğ”¯ğ”ğ”¨ğ”±ğ”²ğ”¯</button>
            <button class="option-button" data-style="boldFraktur">ğ•±ğ–—ğ–†ğ–ğ–™ğ–šğ–— ğ•­ğ–”ğ–‘ğ–‰</button>
            <button class="option-button" data-style="doubleStruck">ğ”»ğ• ğ•¦ğ•“ğ•ğ•– ğ•Šğ•¥ğ•£ğ•¦ğ•”ğ•œ</button>
            <button class="option-button" data-style="sansSerif">ğ–²ğ–ºğ—‡ğ—Œ ğ–²ğ–¾ğ—‹ğ—‚ğ–¿</button>
            <button class="option-button" data-style="sansSerifBold">ğ—¦ğ—®ğ—»ğ˜€ ğ—¦ğ—²ğ—¿ğ—¶ğ—³ ğ—•ğ—¼ğ—¹ğ—±</button>
            <button class="option-button" data-style="sansSerifItalic">ğ˜šğ˜¢ğ˜¯ğ˜´ ğ˜šğ˜¦ğ˜³ğ˜ªğ˜§ ğ˜ğ˜µğ˜¢ğ˜­ğ˜ªğ˜¤</button>
            <button class="option-button" data-style="sansSerifBoldItalic">ğ™ğ™–ğ™£ğ™¨ ğ™ğ™šğ™§ğ™ğ™› ğ˜½ğ™¤ğ™¡ğ™™ ğ™„ğ™©ğ™–ğ™¡ğ™ğ™˜</button>
            <button class="option-button" data-style="monospace">ğ™¼ğš˜ğš—ğš˜ğšœğš™ğšŠğšŒğš</button>
            <button class="option-button" data-style="fullWidth">ï¼¦ï½•ï½Œï½Œã€€ï¼·ï½‰ï½„ï½”ï½ˆ</button>
            <button class="option-button" data-style="smallCaps">sá´á´€ÊŸÊŸ á´„á´€á´˜s</button>
            <button class="option-button" data-style="circled">â’¸â“˜â“¡â“’â“›â“”â““</button>
            <button class="option-button" data-style="negative">ğŸ…ğŸ…”ğŸ…–ğŸ…ğŸ…£ğŸ…˜ğŸ…¥ğŸ…”</button>
            <button class="option-button" data-style="squared">ğŸ„½ğŸ„´ğŸ„¶ğŸ„°ğŸ…ƒğŸ„¸ğŸ……ğŸ„´</button>
            <button class="option-button" data-style="boxed">ğŸ…±ğŸ…¾ğŸ†‡ğŸ…´ğŸ…³</button>
            <button class="option-button" data-style="reversed">desreveR</button>
            <button class="option-button" data-style="upsideDown">uÊop Çpá´‰sdâˆ©</button>
            <button class="option-button" data-style="strikeThrough">SÌ¶tÌ¶rÌ¶iÌ¶kÌ¶eÌ¶tÌ¶hÌ¶rÌ¶oÌ¶uÌ¶gÌ¶hÌ¶</button>
            <button class="option-button" data-style="underline">UÌ²nÌ²dÌ²eÌ²rÌ²lÌ²iÌ²nÌ²eÌ²</button>
            <button class="option-button" data-style="zalgo">ZÌ¸Ì¢Ì Ì€Ì“aÌ´Ì—ÌÌlÌ¸Ì¡Í’ÌŠgÌ´Ì¢Ì”Ì¿á»Ì¸</button>
            <button class="option-button" data-style="bubbleText">â’·â“¤â“‘â“‘â“›â“”</button>
            <button class="option-button" data-style="waveText">Wâ‚aâ‚‚vâ‚ƒeâ‚„</button>
            <button class="option-button" data-style="flourish">â˜…â‹†ï½¡Â°âœ© Flourish âœ©Â°ï½¡â‹†â˜…</button>
            <button class="option-button" data-style="squiggle">ï½ï½ï½ Squiggle ï½ï½ï½</button>
            <button class="option-button" data-style="emojiDecor">âœ¨ğŸ’– Emoji ğŸ’–âœ¨</button>
            <button class="option-button" data-style="cursive">ğ’ğ“Šğ“‡ğ“ˆğ’¾ğ“‹ğ‘’</button>
            <button class="option-button" data-style="sparks">âœ¨Sâœ¨pâœ¨aâœ¨râœ¨kâœ¨sâœ¨</button>
            <button class="option-button" data-style="scriptCalligraphy">ğ’¶ğ’·ğ’¸ğ’¹ ğ’ğ’¶ğ“ğ“ğ’¾ğ‘”ğ“‡ğ’¶ğ“…ğ’½ğ“</button>
            <button class="option-button" data-style="boxed2">ğŸ„°ğŸ„±ğŸ„²ğŸ„³ ğŸ„±ğŸ„¾ğŸ…‡ğŸ„´ğŸ„³</button>
            <button class="option-button" data-style="mirror">ê™…boÉ¿É¿iM</button>
            <button class="option-button" data-style="creepyText">CÌ·ÌµÌ¢rÍ˜ÍeÌ·ÍÍeÍ˜Í¡pyÌ¶Ì¨Ì› Ì§TÌ¸eÌ›Ì•Í˜ÍœxÌ¶Ì§Ì¡tÍ </button>
            <button class="option-button" data-style="superscript">Ë¢áµ˜áµ–áµ‰Ê³Ë¢á¶œÊ³â±áµ–áµ—</button>
            <button class="option-button" data-style="subscript">â‚›áµ¤áµ¦â‚›êœ€áµ£áµ¢â‚šâ‚œ</button>
            <button class="option-button" data-style="blockLetters">ğŸ…° ğŸ…± ğŸ…² ğŸ…³</button>
            <button class="option-button" data-style="regionIndicator">ğŸ‡· ğŸ‡ª ğŸ‡¬ ğŸ‡® ğŸ‡´ ğŸ‡³</button>
        </div>
    </div>

    <!-- New section for special symbols -->
    <div class="special-symbols-container">
        <h3>Special Symbols - One-Click Copy:</h3>
        <div class="options">
            <button class="symbol-button" id="trademarkButton">Trademark (â„¢)</button>
            <button class="symbol-button" id="copyrightButton">Copyright (Â©)</button>
            <button class="symbol-button" id="registeredButton">Registered (Â®)</button>
        </div>
    </div>

    <script>
        // Character maps for various styles
        const charMaps = {
            normal: {},
            bold: {},
            italic: {},
            boldItalic: {},
            script: {},
            boldScript: {},
            fraktur: {},
            boldFraktur: {},
            doubleStruck: {},
            sansSerif: {},
            sansSerifBold: {},
            sansSerifItalic: {},
            sansSerifBoldItalic: {},
            monospace: {},
            fullWidth: {},
            smallCaps: {},
            circled: {},
            negative: {},
            squared: {},
            boxed: {},
            boxed2: {},
            upsideDown: {},
            scriptCalligraphy: {},
            mirror: {},
            superscript: {},
            subscript: {},
            blockLetters: {},
            regionIndicator: {}
        };

        // Initialize normal lowercase letters map
        const lowerAlpha = 'abcdefghijklmnopqrstuvwxyz';
        const upperAlpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';

        // Math bold (ğš-ğ³, ğ€-ğ™, ğŸ-ğŸ—)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.bold[lowerAlpha[i]] = String.fromCodePoint(0x1D41A + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.bold[upperAlpha[i]] = String.fromCodePoint(0x1D400 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.bold[numbers[i]] = String.fromCodePoint(0x1D7CE + i);
        }

        // Math italic (ğ‘-ğ‘§, ğ´-ğ‘)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.italic[lowerAlpha[i]] = String.fromCodePoint(0x1D44E + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.italic[upperAlpha[i]] = String.fromCodePoint(0x1D434 + i);
        }

        // Math bold italic (ğ’‚-ğ’›, ğ‘¨-ğ’)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.boldItalic[lowerAlpha[i]] = String.fromCodePoint(0x1D482 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boldItalic[upperAlpha[i]] = String.fromCodePoint(0x1D468 + i);
        }

        // Math script (ğ“ª-ğ”ƒ, ğ“-ğ“©)
        const scriptChars = "ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ";
        const scriptUpperChars = "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.script[lowerAlpha[i]] = scriptChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.script[upperAlpha[i]] = scriptUpperChars[i] || upperAlpha[i];
        }

        // Script Calligraphy
        const scriptCalligraphyChars = "ğ’¶ğ’·ğ’¸ğ’¹ğ‘’ğ’»ğ‘”ğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒğ‘œğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“";
        const scriptCalligraphyUpperChars = "ğ’œğµğ’ğ’Ÿğ¸ğ¹ğ’¢ğ»ğ¼ğ’¥ğ’¦ğ¿ğ‘€ğ’©ğ’ªğ’«ğ’¬ğ‘…ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.scriptCalligraphy[lowerAlpha[i]] = scriptCalligraphyChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.scriptCalligraphy[upperAlpha[i]] = scriptCalligraphyUpperChars[i] || upperAlpha[i];
        }

        // Math bold script (ğ“«-ğ”ƒ, ğ“-ğ“©)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.boldScript[lowerAlpha[i]] = String.fromCodePoint(0x1D51E + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boldScript[upperAlpha[i]] = String.fromCodePoint(0x1D504 + i);
        }

        // Math fraktur (ğ”-ğ”·, ğ”„-â„¨)
        const frakturLowerChars = "ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·";
        const frakturUpperChars = "ğ”„ğ”…â„­ğ”‡ğ”ˆğ”‰ğ”Šâ„Œâ„‘ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””â„œğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œâ„¨";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.fraktur[lowerAlpha[i]] = frakturLowerChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.fraktur[upperAlpha[i]] = frakturUpperChars[i] || upperAlpha[i];
        }

        // Bold Fraktur
        const boldFrakturLowerChars = "ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ";
        const boldFrakturUpperChars = "ğ•¬ğ•­ğ•®ğ•¯ğ•°ğ•±ğ•²ğ•³ğ•´ğ•µğ•¶ğ•·ğ•¸ğ•¹ğ•ºğ•»ğ•¼ğ•½ğ•¾ğ•¿ğ–€ğ–ğ–‚ğ–ƒğ–„ğ–…";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.boldFraktur[lowerAlpha[i]] = boldFrakturLowerChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boldFraktur[upperAlpha[i]] = boldFrakturUpperChars[i] || upperAlpha[i];
        }

        // Math double-struck (ğ•’-ğ•«, ğ”¸-â„¤, ğŸ˜-ğŸ¡)
        const doubleStruckLowerChars = "ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«";
        const doubleStruckUpperChars = "ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.doubleStruck[lowerAlpha[i]] = doubleStruckLowerChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.doubleStruck[upperAlpha[i]] = doubleStruckUpperChars[i] || upperAlpha[i];
        }
        
        // Sans-serif (ğ–º-ğ—“, ğ– -ğ–¹, ğŸ¢-ğŸ«)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerif[lowerAlpha[i]] = String.fromCodePoint(0x1D5BA + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerif[upperAlpha[i]] = String.fromCodePoint(0x1D5A0 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.sansSerif[numbers[i]] = String.fromCodePoint(0x1D7E2 + i);
        }

        // Sans-serif bold (ğ—®-ğ˜‡, ğ—”-ğ—­, ğŸ¬-ğŸµ)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerifBold[lowerAlpha[i]] = String.fromCodePoint(0x1D5EE + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerifBold[upperAlpha[i]] = String.fromCodePoint(0x1D5D4 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.sansSerifBold[numbers[i]] = String.fromCodePoint(0x1D7EC + i);
        }

        // Sans-serif italic (ğ˜¢-ğ˜», ğ˜ˆ-ğ˜¡)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerifItalic[lowerAlpha[i]] = String.fromCodePoint(0x1D622 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerifItalic[upperAlpha[i]] = String.fromCodePoint(0x1D608 + i);
        }

        // Sans-serif bold italic (ğ™–-ğ™¯, ğ˜¼-ğ™•)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.sansSerifBoldItalic[lowerAlpha[i]] = String.fromCodePoint(0x1D656 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.sansSerifBoldItalic[upperAlpha[i]] = String.fromCodePoint(0x1D63C + i);
        }

        // Monospace (ğšŠ-ğš£, ğ™°-ğš‰, ğŸ¶-ğŸ¿)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.monospace[lowerAlpha[i]] = String.fromCodePoint(0x1D68A + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.monospace[upperAlpha[i]] = String.fromCodePoint(0x1D670 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.monospace[numbers[i]] = String.fromCodePoint(0x1D7F6 + i);
        }

        // Fullwidth (ï½-ï½š, ï¼¡-ï¼º, ï¼-ï¼™)
        const fullWidthLowerChars = "ï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½ï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½š";
        const fullWidthUpperChars = "ï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼º";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.fullWidth[lowerAlpha[i]] = fullWidthLowerChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.fullWidth[upperAlpha[i]] = fullWidthUpperChars[i] || upperAlpha[i];
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.fullWidth[numbers[i]] = String.fromCodePoint(0xFF10 + i);
        }

        // Small caps - approximation for lowercase only
        const smallCapsChars = "á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜QÊ€êœ±á´›á´œá´ á´¡xÊá´¢";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.smallCaps[lowerAlpha[i]] = smallCapsChars[i] || lowerAlpha[i];
        }

        // Circled (â“-â“©, â’¶-â“, â“ª-â‘¨)
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.circled[lowerAlpha[i]] = String.fromCodePoint(0x24D0 + i);
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.circled[upperAlpha[i]] = String.fromCodePoint(0x24B6 + i);
        }
        for (let i = 0; i < numbers.length; i++) {
            charMaps.circled[numbers[i]] = String.fromCodePoint(0x2460 + i - 1);
        }
        charMaps.circled['0'] = 'â“ª';

        // Negative circled (ğŸ…-ğŸ…©)
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.negative[upperAlpha[i]] = String.fromCodePoint(0x1F150 + i);
        }

        // Squared (ğŸ„°-ğŸ„¹)
        const squaredChars = "ğŸ„°ğŸ„±ğŸ„²ğŸ„³ğŸ„´ğŸ„µğŸ„¶ğŸ„·ğŸ„¸ğŸ„¹ğŸ„ºğŸ„»ğŸ„¼ğŸ„½ğŸ„¾ğŸ„¿ğŸ…€ğŸ…ğŸ…‚ğŸ…ƒğŸ…„ğŸ……ğŸ…†ğŸ…‡ğŸ…ˆğŸ…‰";
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.squared[upperAlpha[i]] = squaredChars[i] || upperAlpha[i];
        }

        // Boxed (ğŸ…°-ğŸ…‰)
        const boxedChars = "ğŸ…°ğŸ…±ğŸ…²ğŸ…³ğŸ…´ğŸ…µğŸ…¶ğŸ…·ğŸ…¸ğŸ…¹ğŸ…ºğŸ…»ğŸ…¼ğŸ…½ğŸ…¾ğŸ…¿ğŸ†€ğŸ†ğŸ†‚ğŸ†ƒğŸ†„ğŸ†…ğŸ††ğŸ†‡ğŸ†ˆğŸ†‰";
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boxed[upperAlpha[i]] = boxedChars[i] || upperAlpha[i];
        }

        // Boxed 2 style
        const boxed2Chars = "ğŸ„°ğŸ„±ğŸ„²ğŸ„³ğŸ„´ğŸ„µğŸ„¶ğŸ„·ğŸ„¸ğŸ„¹ğŸ„ºğŸ„»ğŸ„¼ğŸ„½ğŸ„¾ğŸ„¿ğŸ…€ğŸ…ğŸ…‚ğŸ…ƒğŸ…„ğŸ……ğŸ…†ğŸ…‡ğŸ…ˆğŸ…‰";
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.boxed2[upperAlpha[i]] = boxed2Chars[i] || upperAlpha[i];
        }

        // Upside Down (uÊop ÇpÄ±sdn)
        const upsideDownMap = {
            'a': 'É', 'b': 'q', 'c': 'É”', 'd': 'p', 'e': 'Ç', 'f': 'ÉŸ', 'g': 'Æƒ', 'h': 'É¥', 'i': 'Ä±',
            'j': 'É¾', 'k': 'Ê', 'l': 'l', 'm': 'É¯', 'n': 'u', 'o': 'o', 'p': 'd', 'q': 'b', 'r': 'É¹',
            's': 's', 't': 'Ê‡', 'u': 'n', 'v': 'ÊŒ', 'w': 'Ê', 'x': 'x', 'y': 'Ê', 'z': 'z',
            'A': 'âˆ€', 'B': 'á™ ', 'C': 'Æ†', 'D': 'á—¡', 'E': 'Æ', 'F': 'â„²', 'G': 'â…', 'H': 'H', 'I': 'I',
            'J': 'Å¿', 'K': 'â‹Š', 'L': 'Ë¥', 'M': 'W', 'N': 'N', 'O': 'O', 'P': 'Ô€', 'Q': 'ÎŒ', 'R': 'á´š',
            'S': 'S', 'T': 'âŠ¥', 'U': 'âˆ©', 'V': 'Î›', 'W': 'M', 'X': 'X', 'Y': 'â…„', 'Z': 'Z',
            '0': '0', '1': 'Æ–', '2': 'á„…', '3': 'Æ', '4': 'ã„£', '5': 'Ï›', '6': '9', '7': 'ã„¥', '8': '8', '9': '6',
            '.': 'Ë™', ',': '\'', '\'': ',', '"': 'â€', '`': ',', '!': 'Â¡', '?': 'Â¿', '(': ')', ')': '(', '[': ']', ']': '[', '{': '}', '}': '{', '<': '>', '>': '<', '&': 'â…‹'
        };
        
        Object.keys(upsideDownMap).forEach(key => {
            charMaps.upsideDown[key] = upsideDownMap[key];
        });

        // Mirror text
        const mirrorMap = {
            'a': 'É’', 'b': 'd', 'c': 'É”', 'd': 'b', 'e': 'É˜', 'f': 'êŸ»', 'g': 'Ç«', 'h': 'Êœ', 'i': 'i', 
            'j': 'ê', 'k': 'Ê', 'l': 'l', 'm': 'm', 'n': 'á´', 'o': 'o', 'p': 'q', 'q': 'p', 'r': 'É¿',
            's': 'ê™…', 't': 'Æš', 'u': 'u', 'v': 'v', 'w': 'w', 'x': 'x', 'y': 'y', 'z': 'Æ¹',
            'A': 'A', 'B': 'ê“­', 'C': 'Æ†', 'D': 'ê“·', 'E': 'Æ', 'F': 'êŸ»', 'G': 'êš€', 'H': 'H', 'I': 'I',
            'J': 'á‚±', 'K': 'ê¢', 'L': 'â…ƒ', 'M': 'M', 'N': 'Í¶', 'O': 'O', 'P': 'êŸ¼', 'Q': 'á»Œ', 'R': 'Ğ¯',
            'S': 'ê™„', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y', 'Z': 'Æ¸'
        };

        Object.keys(mirrorMap).forEach(key => {
            charMaps.mirror[key] = mirrorMap[key];
        });

        // Superscript
        const superscriptChars = "áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–qÊ³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»";
        const superscriptUpperChars = "á´¬á´®á¶œá´°á´±á¶ á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾Qá´¿Ë¢áµ€áµâ±½áµ‚Ë£Ê¸á¶»";

        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.superscript[lowerAlpha[i]] = superscriptChars[i] || lowerAlpha[i];
        }
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.superscript[upperAlpha[i]] = superscriptUpperChars[i] || upperAlpha[i];
        }

        // Subscript
        const subscriptChars = "â‚bcdâ‚‘fgâ‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šqáµ£â‚›â‚œáµ¤áµ¥wâ‚“yz";
        for (let i = 0; i < lowerAlpha.length; i++) {
            charMaps.subscript[lowerAlpha[i]] = subscriptChars[i] || lowerAlpha[i];
        }
        
        // Block letters
        const blockLettersChars = "ğŸ…°ğŸ…±ğŸ…²ğŸ…³ğŸ…´ğŸ…µğŸ…¶ğŸ…·ğŸ…¸ğŸ…¹ğŸ…ºğŸ…»ğŸ…¼ğŸ…½ğŸ…¾ğŸ…¿ğŸ†€ğŸ†ğŸ†‚ğŸ†ƒğŸ†„ğŸ†…ğŸ††ğŸ†‡ğŸ†ˆğŸ†‰";
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.blockLetters[upperAlpha[i]] = blockLettersChars[i] || upperAlpha[i];
            charMaps.blockLetters[lowerAlpha[i]] = blockLettersChars[i] || lowerAlpha[i];
        }

        // Region indicator (for flag emoji style)
        for (let i = 0; i < upperAlpha.length; i++) {
            charMaps.regionIndicator[upperAlpha[i]] = String.fromCodePoint(0x1F1E6 + i);
            charMaps.regionIndicator[lowerAlpha[i]] = String.fromCodePoint(0x1F1E6 + i);
        }

        // Helper function to apply character map
        function applyCharMap(map, text) {
            return text.split('').map(char => map[char] || char).join('');
        }

        // Special effects functions
        const effects = {
            normal: text => text,
            bold: text => applyCharMap(charMaps.bold, text),
            italic: text => applyCharMap(charMaps.italic, text),
            boldItalic: text => applyCharMap(charMaps.boldItalic, text),
            script: text => applyCharMap(charMaps.script, text),
            boldScript: text => applyCharMap(charMaps.boldScript, text),
            fraktur: text => applyCharMap(charMaps.fraktur, text),
            boldFraktur: text => applyCharMap(charMaps.boldFraktur, text),
            doubleStruck: text => applyCharMap(charMaps.doubleStruck, text),
            sansSerif: text => applyCharMap(charMaps.sansSerif, text),
            sansSerifBold: text => applyCharMap(charMaps.sansSerifBold, text),
            sansSerifItalic: text => applyCharMap(charMaps.sansSerifItalic, text),
            sansSerifBoldItalic: text => applyCharMap(charMaps.sansSerifBoldItalic, text),
            monospace: text => applyCharMap(charMaps.monospace, text),
            fullWidth: text => applyCharMap(charMaps.fullWidth, text),
            smallCaps: text => applyCharMap(charMaps.smallCaps, text),
            circled: text => applyCharMap(charMaps.circled, text),
            negative: text => applyCharMap(charMaps.negative, text),
            squared: text => applyCharMap(charMaps.squared, text),
            boxed: text => applyCharMap(charMaps.boxed, text),
            boxed2: text => applyCharMap(charMaps.boxed2, text),
            reversed: text => text.split('').reverse().join(''),
            upsideDown: text => applyCharMap(charMaps.upsideDown, text.split('').reverse().join('')),
            strikeThrough: text => text.split('').join('Ì¶') + 'Ì¶',
            underline: text => text.split('').join('Ì²') + 'Ì²',
            zalgo: text => {
                const zalgo_up = ["\u030d","\u030e","\u0304","\u0305","\u033f","\u0311","\u0306"];
                const zalgo_mid = ["\u0315","\u031b","\u0340","\u0341","\u0358","\u0321"];
                const zalgo_down = ["\u0316","\u0317","\u0318","\u0319","\u031c","\u031d","\u031e","\u031f","\u0320","\u0324","\u0325","\u0326"];
                return text.split('').map(char => {
                    let result = char;
                    // Limit the number of combining characters to avoid extreme height
                    let numUp = Math.floor(Math.random() * 2) + 1;
                    let numMid = Math.floor(Math.random() * 2);
                    let numDown = Math.floor(Math.random() * 2) + 1;
                    
                    for (let i = 0; i < numUp; i++) {
                        result += zalgo_up[Math.floor(Math.random() * zalgo_up.length)];
                    }
                    for (let i = 0; i < numMid; i++) {
                        result += zalgo_mid[Math.floor(Math.random() * zalgo_mid.length)];
                    }
                    for (let i = 0; i < numDown; i++) {
                        result += zalgo_down[Math.floor(Math.random() * zalgo_down.length)];
                    }
                    return result;
                }).join('');
            },
            bubbleText: text => text.split('').map(c => {
                if (c.match(/[a-z]/i)) {
                    return charMaps.circled[c] || c;
                }
                return c;
            }).join(''),
            waveText: text => text.split('').map((c, i) => {
                const wave = ["â‚", "â‚‚", "â‚ƒ", "â‚„", "â‚ƒ", "â‚‚"];
                return c + (wave[i % wave.length] || "");
            }).join(''),
            flourish: text => "â˜…â‹†ï½¡Â°âœ© " + text + " âœ©Â°ï½¡â‹†â˜…",
            squiggle: text => "ï½ï½ï½ " + text + " ï½ï½ï½",
            emojiDecor: text => "âœ¨ğŸ’– " + text + " ğŸ’–âœ¨",
            cursive: text => applyCharMap(charMaps.script, text),
            sparks: text => "âœ¨" + text.split('').join('âœ¨') + "âœ¨",
            scriptCalligraphy: text => applyCharMap(charMaps.scriptCalligraphy, text),
            mirror: text => applyCharMap(charMaps.mirror, text.split('').reverse().join('')),
            creepyText: text => {
                // This is a simplified version of zalgo with fewer combining characters
                const zalgo_chars = ["\u0300", "\u0301", "\u0302", "\u0303", "\u0304", "\u0305", "\u0306", "\u0307"];
                return text.split('').map(char => {
                    let result = char;
                    let numChars = Math.floor(Math.random() * 2) + 1; // 1-2 combining characters
                    
                    for (let i = 0; i < numChars; i++) {
                        result += zalgo_chars[Math.floor(Math.random() * zalgo_chars.length)];
                    }
                    return result;
                }).join('');
            },
            superscript: text => applyCharMap(charMaps.superscript, text),
            subscript: text => applyCharMap(charMaps.subscript, text),
            blockLetters: text => text.split('').map(c => {
                if (c.match(/[a-z]/i)) {
                    return charMaps.blockLetters[c] || c;
                }
                return c;
            }).join(' '),
            regionIndicator: text => text.split('').map(c => {
                if (c.match(/[a-z]/i)) {
                    return charMaps.regionIndicator[c] || c;
                }
                return c;
            }).join(' ')
        };

        // Helper function for copying text with no feedback
        function copyToClipboard(text) {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            // No feedback at all
        }

        // Function to generate all transformed texts
        function generateAllTransforms(text) {
            if (!text) return '';
            
            let output = '';
            const styleNames = {
                normal: "Normal",
                bold: "Bold",
                italic: "Italic",
                boldItalic: "Bold Italic",
                script: "Script",
                boldScript: "Bold Script",
                fraktur: "Fraktur",
                boldFraktur: "Bold Fraktur",
                doubleStruck: "Double Struck",
                sansSerif: "Sans Serif",
                sansSerifBold: "Sans Serif Bold",
                sansSerifItalic: "Sans Serif Italic",
                sansSerifBoldItalic: "Sans Serif Bold Italic",
                monospace: "Monospace",
                fullWidth: "Full Width",
                smallCaps: "Small Caps",
                circled: "Circled",
                negative: "Negative",
                squared: "Squared",
                boxed: "Boxed",
                boxed2: "Boxed Style 2",
                reversed: "Reversed",
                upsideDown: "Upside Down",
                strikeThrough: "Strikethrough",
                underline: "Underline",
                zalgo: "Zalgo",
                bubbleText: "Bubble",
                waveText: "Wave",
                flourish: "Flourish",
                squiggle: "Squiggle",
                emojiDecor: "Emoji Decorated",
                cursive: "Cursive",
                sparks: "Sparks",
                scriptCalligraphy: "Script Calligraphy",
                mirror: "Mirror",
                creepyText: "Creepy Text",
                superscript: "Superscript",
                subscript: "Subscript",
                blockLetters: "Block Letters",
                regionIndicator: "Region Indicator"
            };
            
            for (const style in effects) {
                if (effects.hasOwnProperty(style)) {
                    const transformedText = effects[style](text);
                    output += `${transformedText}\n\n`;
                }
            }
            
            return output;
        }

        // Event listener for the main copy button
        document.getElementById('copyButton').addEventListener('click', function() {
            const outputText = document.getElementById('output');
            outputText.select();
            document.execCommand('copy');
            // No feedback
        });

        // Event listeners for style option buttons
        document.querySelectorAll('.option-button').forEach(button => {
            button.addEventListener('click', function() {
                const style = this.dataset.style;
                const inputText = document.getElementById('input').value;
                
                if (inputText) {
                    const transformedText = effects[style](inputText);
                    copyToClipboard(transformedText);
                }
            });
        });

        // Event listeners for special symbol buttons
        document.getElementById('trademarkButton').addEventListener('click', function() {
            copyToClipboard('â„¢');
        });

        document.getElementById('copyrightButton').addEventListener('click', function() {
            copyToClipboard('Â©');
        });

        document.getElementById('registeredButton').addEventListener('click', function() {
            copyToClipboard('Â®');
        });

        // Initialize text transformation on input
        document.getElementById('input').addEventListener('input', function() {
            document.getElementById('output').value = generateAllTransforms(this.value);
        });
    </script>
</body>
</html>
